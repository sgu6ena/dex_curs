# Классы
```js
class MyClass {
    prop = value; // свойство
    constructor(...) { // конструктор
        // ...
    }

    method(...) {
    } // метод
    get something(...) {
    } // геттер
    set something(...) {
    } // сеттер
    [Symbol.iterator]() {
    } // метод с вычисляемым именем (здесь - символом)
// ...
}
```
* Чтобы унаследовать от класса: `class Child extends Parent`:
* При этом `Child.prototype.__proto__` будет равен `Parent.prototype`, так что методы будут унаследованы.
  * При переопределении конструктора:
  * Обязателен вызов конструктора родителя `super()` в конструкторе `Child` до обращения к `this`.
* При переопределении другого метода:
  * Мы можем вызвать `super.method()` в методе `Child` для обращения к методу родителя `Parent`.
* Внутренние детали:
  * Методы запоминают свой объект во внутреннем свойстве `[[HomeObject]]`. 
  * Благодаря этому работает super, он в его прототипе ищет родительские методы. 
  * Поэтому копировать метод, использующий super, между разными объектами небезопасно.
* Также:
  * У функций-стрелок **нет своего** `this` и `super`, поэтому они «прозрачно» встраиваются во внешний контекст.
___


# Модули

Модули могут загружать друг друга и использовать директивы `export` и `import`, чтобы обмениваться функциональностью,
вызывать функции одного модуля из другого:

* **export** отмечает переменные и функции, которые должны быть доступны вне текущего модуля.
* **import** позволяет импортировать функциональность из других модулей.

### Экспорт
Перед объявлением класса/функции/…:
```js
export [default] class/function/variable ...
```

Отдельный экспорт:
```js
export {x [as y], ...}.
```

Реэкспорт:
```js
export {x [as y], ...} from "module"
```

```js
export * from "module" (не реэкспортирует export default).
```

```js
export {default [as y]} from "module" (реэкспортирует только export default).
```

### Импорт

Именованные экспорты из модуля:
```js
import {x [as y], ...} from "module"
```

Импорт по умолчанию:
```js
import x from "module"
```

```js
import {default as x} from "module"
```

Всё сразу:
```js
import * as obj from "module"
```

Только подключить модуль (его код запустится), но не присваивать его переменной:
```js
import "module"
```

Мы можем поставить import/export в начало или в конец скрипта, это не имеет значения.

На практике импорты, чаще всего, располагаются в начале файла. Но это только для большего удобства.

Обратите внимание, что инструкции import/export не работают внутри {...}.

>Условный импорт, такой как ниже, работать не будет:
>```js
>if (something) {
>// Ошибка: импорт должен быть на верхнем уровне
>   import {sayHi} from "./say.js";
>}
>```

## Динамический экспорт
```js
let modulePath = prompt("Какой модуль загружать?");

import(modulePath)
    .then(obj => <объект модуля>)
    .catch(err => <ошибка загрузки, например если нет такого модуля>)
```
```js
let module = await import(modulePath)
```


```js
let {default: say} = await import('./say.js');
```


# setTimeout / setInterval

*  `setTimeout` позволяет вызвать функцию один раз через определённый интервал времени.
```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```
 *  `setInterval` позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.
```js
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```
* **func|code** - 
Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.  
* **delay** - 
Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – 0.  
* **arg1, arg2…**  - Аргументы, передаваемые в функцию  

### Отмена
Вызов setTimeout возвращает «идентификатор таймера» timerId, который можно использовать для отмены дальнейшего выполнения.

Синтаксис для отмены:
```js
let timerId = setTimeout(...);
clearTimeout(timerId);
```



* Методы `setInterval(func, delay, ...args)` и `setTimeout(func, delay, ...args)` позволяют выполнять func регулярно или только один раз после задержки `delay`, заданной в мс.
* Для отмены выполнения необходимо вызвать `clearInterval/clearTimeout` со значением, которое возвращают методы `setInterval/setTimeout`.
* Вложенный вызов `setTimeout` является более гибкой альтернативой `setInterval`. Также он позволяет более точно задать интервал между выполнениями.
* Планирование с нулевой задержкой `setTimeout(func,0)` или, что то же самое, `setTimeout(func)` используется для вызовов, которые должны быть исполнены как можно скорее, после завершения исполнения текущего кода.
* Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными вызовами `setTimeout`, а также для `setInterval`, начиная с 5-го вызова.

> Все методы планирования не гарантируют точную задержку!!!

Таймер в браузере может замедляться по многим причинам:

* Перегружен процессор.
* Вкладка браузера в фоновом режиме.
* Работа ноутбука от аккумулятора.
Всё это может увеличивать минимальный интервал срабатывания таймера (и минимальную задержку) до 300 или даже 1000 мс в зависимости от браузера и настроек производительности ОС.