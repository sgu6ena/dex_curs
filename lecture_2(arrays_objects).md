# Массивы

___

## Добавление/удаление элеметов

* **`el = arr.pop()`** - удаляет последний элемент из массива и возвращает его
* **`arr.push(el)`** - добавляет элемент в конец массива
* **`el = arr.shift()`** - удаляет из массива первый элемент и возвращает его
* **`arr.unshift(el)`** - добавляет элемент в начало массива

  > Методы `push/pop` выполняются быстро, а методы `shift/ unshift` – медленно, так как `shift/unshift` не просто удаляет/добавляет элемент в начало, но и сдвигает другие элементы.

* **`arr.splice(str)`** – добавлять, удалять и заменять элементы
    * `arr.slice( indexStart, n )` - удалит n элементов начиная с indexStart
    * `arr.slice( indexStart, n , ...el)` - заменит n элементов начиная с indexStart на ...el. если n = 0 - просто
      вставит элементы

* **`newArr = arr.slice(start, end)`** - копирует элементы со start до end в **новый** массив. если без параметров -
  создает полную копию массива
* **`newArr = arr.concat(...el)`** - создаёт **новый** массив, в который копирует данные из других массивов и
  дополнительные значения.

___

## Поиск в массиве

* **`arr.indexOf(item, from)`** ищет item, начиная с индекса from, и возвращает индекс, на котором был найден искомый
  элемент, в противном случае -1.
* **`arr.lastIndexOf(item, from)`** – ищет справа налево.
* **`arr.includes(item, from)`** – ищет item, начиная с индекса from, и возвращает true, если поиск успешен.
* **`el = arr.find(item=>item.id>0)`** - ищет **ПЕРВЫЙ** объект с определённым условием
* **`index = arr.findIndex(item=>item.id>0)`**– возвращает **ПЕРВЫЙ** индекс, на котором был найден элемент, а не сам
  элемент, и -1, если ничего не найдено
* **`newArr = arr.filter(callback)`** - **ВСЕ** найденые результаты

---

## Перебор массива

* `for (let el of arr ){ ... }`
* `arr.forEach( (item, index, arr) => { ... } );`

---

## Преобразование массива

* **`newArr = arr.map( (item, index, array)=>{ ... } )`** - Он вызывает функцию для каждого элемента массива и
  возвращает массив результатов выполнения этой функции.
* **`arr.sort((a,b)=>a-b)`** - сортирует массив согласно функции коллбеку
* **`arr.reverse()`** - переворачивает массив
* **`str.split(delim)`** - преобразует строку в массив через разделитель delim
* **`str.join(delim)`** - преобразует массив в строку через разделитель delim
* **`str.reduce((total,count)=> total+=count, 0)`** - вычисляет одно значение на основе всего массива, вызывая функцию
  для каждого элемента и передавая промежуточный результат между итерациями. В конце дописывается начальное значение

> > > > Методы sort, reverce и splice изменяют исходный массив!!!

___

### Дополнительно

* **`Array.isArray(arr)`** - проверяет, является ли arr массивом
* **`arr.some(fn)/arr.every(fn)`** - проверяет массив. если какие либо(some)/все(every) результаты вызовов являются 
true - то метод возращает true, иначе false
* **`arr.fill(value, start, end)`** - заполняет массив повторяющимися value, начиная c индекса start до end
* **`arr.copyWithin(target, start, end)`** - копирует свои элементы, начиная со start и заканчивая end, в собственную 
позицию target (перезаписывает существующие)