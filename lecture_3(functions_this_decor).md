# Функции

## Function Declaration

**Function Declaration** - функция объявляется отдельной конструкцией «function…» в основном потоке кода.
> Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).

```js
function sum(a, b) {   
    return a + b;   
}
```


___

## Function Expression

**Function Expression** - функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае
функция создаётся в правой части «выражения присваивания» =:

```js
let sum = function(a, b) {  
    return a + b; 
};
 ```

> Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

___

## Arrow functions

**Arrow functions** - Стрелочные функции:

* Без фигурных скобок: `(...args) => expression` – правая сторона выражение: функция выполняет его и возвращает
  результат.
* С фигурными скобками: `(...args) => { body }` – скобки позволяют нам писать многострочные инструкции внутри функции,
  но при этом необходимо указывать директиву return, чтобы вернуть какое-либо значение.

    * Не имеют **this**
    * Не имеют **arguments**
    * Не могут быть вызваны с **new**
    * Нет **super**

___

# Деструктуризация

> Деструктуризация позволяет разбивать объект или массив на переменные при присвоении.

* Деструктуризация объекта

```js
let {prop : varName = default, ...rest} = object
```

Свойства, которые не были упомянуты, копируются в объект rest.

* Деструктуризация массива

```js
let [item1 = default, item2, ...rest] = array
```

Первый элемент отправляется в item1; второй отправляется в item2, все остальные элементы попадают в массив rest.

Можно извлекать данные из вложенных объектов и массивов, для этого левая сторона должна иметь ту же структуру, что и
правая.

___

# Контекст - this

**this** — это ссылка на некий объект, к свойствам которого можно достучаться внутри вызова функции. Этот this — и есть
контекст выполнения.

* В **нестрогом режиме** при выполнении в браузере `this` при вызове функции будет равен `window`
* В **строгом режиме** — значение будет равно `undefined`
* Если функция хранится в объекте — это метод этого объекта.

> `this` определяется в момент вызова функции. Если записать метод объекта в переменную и вызвать её, значение this изменится.

> `user.greet` значение `this` равняется объекту до точки (`user`). Без этого объекта `this` равняется *глобальному объекту* (в обычном режиме).

* При вызове **конструктора** `this` равен свежесозданному объекту.

## Непрямой вызов - .call() и .apply()

> Оба первым аргументом принимают `this`. То есть они позволяют настроить контекст снаружи, к тому же — явно.

* `.call()` принимает аргументы списком через запятую

`func.call(context, ...args); `

* `.apply()` принимает массив аргументов

`  func.apply(context, args); `

> Оператор расширения `...` позволяет передавать перебираемый объект `args` **в виде списка** в `call`.  
> А `apply` принимает только **псевдомассив** `args`.

* `.bind()` позволяет связывать контекст выполнения с функцией, чтобы «заранее и точно» определить, какое именно
  значение будет у `this`

> .bind() в отличие от .call() и .apply() не вызывает функцию сразу. Вместо этого он возвращает другую функцию — связанную с указанным контекстом навсегда. Контекст у этой функции изменить невозможно.

> У стрелочных функций собственного контекста выполнения нет. Они связываются с ближайшим по иерархии контекстом, в котором они определены.

___

# Декораторы

> **Декоратор** – это обёртка вокруг функции, которая изменяет поведение последней. Основная работа по-прежнему выполняется функцией

* `func.call(context, arg1, arg2…)` – вызывает func с данным контекстом и аргументами.
* `func.apply(context, args)` – вызывает func, передавая context как this и псевдомассив args как список аргументов. В
  основном переадресация вызова выполняется с помощью apply:

```js
let wrapper = function(original, arguments) {
   return original.apply(this, arguments); 
};
 ```

 
Весьма распространено заимствовать методы массива и применять их к arguments.   
В качестве альтернативы можно использовать объект
с остаточными параметрами `...args` , который является реальным массивом.